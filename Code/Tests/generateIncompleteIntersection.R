# Return a list containing a matrix of unique rows in a matrix, a
# vector containing the number of times each unique row appears in the
# original matrix and a vector of probabilities generated by
# normalizing the counts.
uniqueRows <- function(mat) {
  uniqueMat <- unique(mat)
  countMatchedRows <- function(row, matrix)
    sum(apply(matrix, 1, function(x) all(x==row)))
  counts <- apply(uniqueMat, 1, countMatchedRows, matrix=uniqueMat)
  prob <- counts / sum(counts)
  return(list(unique=uniqueMat, counts=counts, prob=prob))
}

#' Generate Missingness
#'
#' Given a tibble with some missingness, and a large number of complete
#' observations, it will return the complete subset of the data with missing
#' forced upon it following a similar distribution of the overall missinginess.
#'
#' @param data a tibble with some missingness and some complete observations.
#'
#' @return a tibble with similar missingness to the original tibble
generateIncompleteIntersection <- function(data) {

  complete_dat <- data %>% filter_all(all_vars(!is.na(.)))

  # sampled_missing is a tibble where all values are True if the corresponding
  # value in complete_dat should become missing and False if it should stay the
  # same.
  sampled_missing <- data %>% mutate_all(is.na) %>%
    sample_n(., length(complete_dat[[1]]), replace = T)

  # force missingness onto the complete subset and return that tibble
  mapply(function(dat, missing) ifelse(missing, NA, dat), complete_dat, sampled_missing, SIMPLIFY = F) %>%
    as_tibble()
}

